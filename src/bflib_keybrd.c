/******************************************************************************/
// Bullfrog Engine Emulation Library - for use to remake classic games like
// Syndicate Wars, Magic Carpet or Dungeon Keeper.
/******************************************************************************/
// Author:  Tomasz Lis
// Created: 10 Feb 2008

// Purpose:
//    Keyboard related routines - reading keyboard.

// Comment:
//   None yet.

//Copying and copyrights:
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
/******************************************************************************/
#include "bflib_keybrd.h"

#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include "bflib_mouse.h"

#ifdef __cplusplus
extern "C" {
#endif
/******************************************************************************/
unsigned char lbKeyOn[256];
unsigned char lbShift;
unsigned char lbIInkeyFlags;
unsigned char lbInkey;
unsigned char lbIInkey;
unsigned char lbInkeyFlags;
unsigned short flow_control_flags;
unsigned long text_buf_pos;
bool lbExtendedKeyPress=false;

const char AsciiToInkey[] = {
   0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
   0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
   0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
   0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x39, 0x2, 0x3,0x2B, 0x5, 0x6, 0x8,0x28,
  0x0A,0x0B, 0x9,0x4E,0x33,0x0C,0x34,0x35,
  0x0B, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8,
   0x9,0x0A,0x27,0x27,0x33,0x0D,0x34,0x35,
  0x28,0x1E,0x30,0x2E,0x20,0x12,0x21,0x22,
  0x23,0x17,0x24,0x25,0x26,0x32,0x31,0x18,
  0x19,0x10,0x13,0x1F,0x14,0x16,0x2F,0x11,
  0x2D,0x15,0x2C,0x1A,0x56,0x1B, 0x7,0x0C,
  0x29,0x1E,0x30,0x2E,0x20,0x12,0x21,0x22,
  0x23,0x17,0x24,0x25,0x26,0x32,0x31,0x18,
  0x19,0x10,0x13,0x1F,0x14,0x16,0x2F,0x11,
  0x2D,0x15,0x2C,0x1A,0x56,0x1B,0x2B, 0x0,
};

char lbInkeyToAscii[] = {
  0x0, 0x0,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x2D,
 0x3D, 0x8, 0x9,0x71,0x77,0x65,0x72,0x74,0x79,0x75,0x69,0x6F,0x70,
 0x5B,0x5D, 0x0, 0x0,0x61,0x73,0x64,0x66,0x67,0x68,0x6A,0x6B,0x6C,
 0x3B,0x27,0x60, 0x0,0x23,0x7A,0x78,0x63,0x76,0x62,0x6E,0x6D,0x2C,
 0x2E,0x2F, 0x0,0x2A, 0x0,0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,0x2D, 0x0, 0x0, 0x0,
 0x2B, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,0x5C, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0,0x2F, 0x0, 0x0,0x28,0x29,0x2F,0x2A, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,0x2E, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

char lbInkeyToAsciiShift[] = {
  0x0, 0x0,0x21,0x22,0x9C,0x24,0x25,0x5E,0x26,0x2A,0x28,0x29,0x5F,
 0x2B, 0x8, 0x9,0x51,0x57,0x45,0x52,0x54,0x59,0x55,0x49,0x4F,0x50,
 0x7B,0x7D, 0x0, 0x0,0x41,0x53,0x44,0x46,0x47,0x48,0x4A,0x4B,0x4C,
 0x3A,0x40,0x7E, 0x0,0x7E,0x5A,0x58,0x43,0x56,0x42,0x4E,0x4D,0x3C,
 0x3E,0x3F, 0x0,0x2A, 0x0,0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,0x2D, 0x0, 0x0, 0x0,
 0x2B, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,0x7C, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0,0x2F, 0x0, 0x0,0x28,0x29,0x2F,0x2A, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,0x2E, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

/******************************************************************************/
void KInt(void)
{
  static unsigned char oinkey=0;
  lbInkey=0;//_GETDS();
  unsigned int v1;
  if (oinkey==0xE0)
  {
    lbExtendedKeyPress=false;
    v1 = lbInkey&0x7F;
    lbKeyOn[v1] = (lbInkey<=0x7F); //lbInkey<=0x7F means the key was pressed, not released
  } else
  {
    lbExtendedKeyPress=true;
    if ((lbInkey!=0x2a)&&(lbInkey!=0xaa))
    {
      v1 = lbInkey|0x80;
      lbKeyOn[v1] = (lbInkey<=0x7F);
    } else
    {
      lbInkey = 0x80;
      v1 = 0x80;
    }
  }
  oinkey=lbInkey;
  lbInkeyFlags=0;
  if ((lbKeyOn[0x2a]!=0)||(lbKeyOn[0x36]!=0))
    lbInkeyFlags|=0x10;
  if ((lbKeyOn[0x1d]!=0)||(lbKeyOn[0x9d]!=0))
    lbInkeyFlags|=0x20;
  if ((lbKeyOn[0x38]!=0)||(lbKeyOn[0xb8]!=0))
    lbInkeyFlags|=0x40;
  if (lbKeyOn[v1]!=0)
    lbKeyOn[v1]|=lbInkeyFlags;
/*
  ... some direct keyboard control code here
  changes v1, bot without storing in global variables.
*/
}

/*
inline void __fastcall LbProcessAllEvents()
{
  SDL_Event event;
  while(SDL_PollEvent(&event))
  {
    switch(event.type)
    {
    case SDL_KEYDOWN:
    case SDL_KEYUP:
      LbStoreKeyStoke(&event.key);
      break;
    case SDL_MOUSEMOTION:
      LbProcessMouseMove(&event.motion);
      break;
    case SDL_MOUSEBUTTONDOWN:
    case SDL_MOUSEBUTTONUP:
      LbProcessMouseClick(&event.button);
      break;
    case SDL_QUIT:
      flow_control_flags|=1;
      break;
    }
  }
}
*/

int __fastcall LbIKeyboardOpen(void)
{
  memset(lbKeyOn, 0, 256);
/* Setting interrupt should be replaced by SDL initation
  void *v1; // edx@1
  OldInt = dos_getvect(9);
  word_200510 = v1;
  dos_setvect(9,v1);
*/
  return 1;
}

int __fastcall LbIKeyboardClose(void)
{
/* Setting interrupt should be replaced by SDL initation
  void *edx0; // edx@0
  dos_setvect_(9, edx0);
*/
  return 1;
}

char __fastcall LbDosKeyboard()
{
  char result;
  result=0;
/* Calling interrupt should be replaced by SDL
  char v1; // [sp+1h] [bp-1Bh]@1
  char regs; // [sp+0h] [bp-1Ch]@1
  v1 = 18;
  result = int386_();
  lbShift = 0;
  if ( regs & 3 )
    lbShift = 1;
  if ( regs & 4 )
    lbShift = (unsigned __int8)lbShift | 2;
  if ( regs & 8 )
    lbShift = (unsigned __int8)lbShift | 4;
  lbInkey = 0;
  __asm { int     16h             ; KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
*/
  return result;
}

char __fastcall LbKeyboard()
{
  char result;
  LbDosKeyboard();
  if ( ((unsigned char)lbInkey) >= 128 )
    result = 0;
  else
    result = lbInkeyToAscii[lbInkey];
  return result;
}
/*
int __fastcall control_process(void)
{
  LbProcessAllEvents();
  if ( lbKeyOn[0x2a] || lbKeyOn[0x36] )
    lbShift |= 1;
  else
    lbShift &= 0x0FEu;
  if ( lbKeyOn[0x1d] )
    lbShift |= 0x02;
  else
    lbShift &= 0x0FDu;
  if ( lbKeyOn[0x0b8] || lbKeyOn[0x38] )
  {
    lbShift |= 0x04;
    if ( lbInkey == 45 )
    {
      flow_control_flags |= 0x0001;
      lbInkey = 0;
    }
  }
  else
  {
    lbShift &= 0x0FBu;
  }
  return 0;
}
*/
/******************************************************************************/
#ifdef __cplusplus
}
#endif
